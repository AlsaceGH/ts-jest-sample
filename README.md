# Sample Project using ts-jest

The goal in this project is to create a TypeScript project that can do all of the following:

* Compile code an es5 library that can be published as a Node module with typings.
* Using `jest` and `ts-jest` for testing
* Provide accurate code coverage metrics
* Can be debugged using the Node debugger with proper source maps
* Provides proper stack traces for failed tests

## Basic Setup

### Module and Dependencies

I start by initialing this as an `npm` project.

```sh
$ yarn init .
```

Then, I install `typescript`, `jest`, `ts-jest` and `@types/jest` as dependencies:

```sh
$ yarn add -D typescript jest ts-jest @types/jest
```

At the time of this writing, that means `typescript@2.7.1`, `jest@22.1.4` and `ts-jest@22.0.2`.

### TypeScript

Next, we initialize this as a TypeScript project using:

```sh
$ npx tsc --init .
```

I want my TypeScript generated code to be stored in `./lib` and I want declarations generated.
So, I configure `outDir` in `tsconfig.json` to be `./lib`.

### Files

My `.gitignore` is then configured to be:

```sh
/node_modules
/lib
```

...while my `.npmignore` is just:

```sh
/node_modules
```

For the same reason, I remove the default value for `files` in `tsconfig.json` and replace it with:

```json
    "exclude": ["node_modules", "lib"]
```

### Source

To start, I create a `src/index.ts` that contains a simple function:

```typescript
export function sampleFunction(x: string): string {
    return x + x;
}
```

I also add a simple `jest` test. I prefer to keep my tests in a completely separate
location, so I'll put all my tests in `__tests__`. So I create the following test case
in `__tests__/base.spec.ts`:

```typescript
import { sampleFunction } from "../src";

describe("This is a simple test", () => {
    test("Check the sampleFunction function", () => {
        expect(sampleFunction("hello")).toEqual("hellohello");
    });
});
```

### Configurating Jest

At this point, I'd like to run that test. But first I need to create a `jest.config.js`
file for all my `jest` settings. This has to take into account the fact that I'm using
`ts-jest` and the fact that my tests are stored in `__tests__`. So the resulting file
looks like this:

```js
module.exports = {
    transform: {
        "^.+\\.tsx?$": "ts-jest",
    },
    testRegex: "(/__tests__/.*|(\\.|/)(test|spec))\\.(jsx?|tsx?)$",
    moduleFileExtensions: ["ts", "tsx", "js", "jsx", "json", "node"],
};
```

### Scripts

I then add the following scripts to `package.json`:

```json
  "scripts": {
    "compile": "tsc",
    "test": "jest"
  }
```

At this point, if I run `yarn test`, I get exactly what I was hoping for:

```
 PASS  __tests__/base.spec.ts
  This is a simple test
    ✓ Check the sampleFunction function (3ms)

Test Suites: 1 passed, 1 total
Tests:       1 passed, 1 total
```

## Code Coverage

### Configuration

To enable code coverage, I update my `jest.config.js` file to:

```js
module.exports = {
    transform: {
        "^.+\\.tsx?$": "ts-jest",
    },
    testRegex: "(/__tests__/.*|(\\.|/)(test|spec))\\.(jsx?|tsx?)$",
    moduleFileExtensions: ["ts", "tsx", "js", "jsx", "json", "node"],
    collectCoverage: true,
    mapCoverage: true,
};
```

I'll also want to update my `.gitignore` and `.npmignore` files to avoid version
controlling or publishing the `coverage` directory generated by `jest`.

### Code Organization

At this point, I'm going to start introducing sub-modules in my project. So I'll add a
`src/core` and a `src/utils` module just so make things sligtly more realistic. Then I'll
export the contents of both of these so that `src/index.ts` looks like this:

```typescript
export * from "./core";
export * from "./utils";
```

These then import specific files containing various types and functions. Initially, I'll
create a very simple set of types for representing extremely simple expressions with only
literals and the binary operations `+`, `-`, `*` and `/`. Then I can write a few tests
like these:

```typescript
import { evaluate, Expression } from "../src";

describe("Simple expression tests", () => {
    test("Check literal value", () => {
        expect(evaluate({ type: "literal", value: 5 })).toBeCloseTo(5);
    });
    test("Check addition", () => {
        let expr: Expression = {
            type: "binary",
            operator: "+",
            left: {
                type: "literal",
                value: 5,
            },
            right: {
                type: "literal",
                value: 10,
            },
        };
        expect(evaluate(expr)).toBeCloseTo(15);
    });
});
```

So far so good. But note that if I actually run these tests, I get these results:

```
 PASS  __tests__/base.spec.ts
  Simple expression tests
    ✓ Check literal value (4ms)
    ✓ Check addition

Test Suites: 1 passed, 1 total
Tests:       2 passed, 2 total
Snapshots:   0 total
Time:        2.048s
Ran all test suites.
---------------|----------|----------|----------|----------|----------------|
File           |  % Stmts | % Branch |  % Funcs |  % Lines |Uncovered Lines |
---------------|----------|----------|----------|----------|----------------|
All files      |    66.67 |     37.5 |       50 |    66.67 |                |
 src           |      100 |      100 |      100 |      100 |                |
  index.ts     |      100 |      100 |      100 |      100 |                |
 src/core      |    61.54 |     37.5 |      100 |    61.54 |                |
  functions.ts |    54.55 |     37.5 |      100 |    54.55 | 14,16,18,20,25 |
  index.ts     |      100 |      100 |      100 |      100 |                |
 src/utils     |    66.67 |      100 |        0 |    66.67 |                |
  checks.ts    |       50 |      100 |        0 |       50 |              2 |
  index.ts     |      100 |      100 |      100 |      100 |                |
---------------|----------|----------|----------|----------|----------------|
```

Note the lack of code coverage.
